# Alternate-load config to surface high-latency iterations despite visible overlap.
RunOptions:
  world_size: 4
  num_batches: 8
  sharding_type: table_row_wise
  compute_kernel: quant_uvm
  profile_dir: "./trace_overlap_latency"
  name: "sparse_data_dist_overlap_latency"
  planner_type: "hetero"
  pooling_factors: [0.35, 0.35, 0.6, 0.6, 0.35, 0.35, 0.6, 0.6]
  num_poolings: [2.0, 2.0, 4.0, 4.0, 2.0, 2.0, 4.0, 4.0]

PipelineConfig:
  pipeline: "prefetch"

ModelSelectionConfig:
  model_name: "test_sparse_nn"
  batch_size: 65536
  batch_sizes: [8192, 65536, 8192, 65536, 4096, 65536, 4096, 65536]
  num_float_features: 96
  feature_pooling_avg: 12
  pin_memory: true
  long_kjt_indices: true
  long_kjt_offsets: true
  long_kjt_lengths: false

EmbeddingTablesConfig:
  num_unweighted_features: 192
  num_weighted_features: 192
  embedding_feature_dim: 96
  additional_tables:
    - - name: latency_table_0
        embedding_dim: 192
        num_embeddings: 3_000_000
        feature_names: ["latency_0"]
      - name: latency_table_1
        embedding_dim: 192
        num_embeddings: 2_500_000
        feature_names: ["latency_1"]
    - - name: weighted_latency_table_0
        embedding_dim: 96
        num_embeddings: 2_000_000
        feature_names: ["weighted_latency_0"]
      - name: weighted_latency_table_1
        embedding_dim: 96
        num_embeddings: 2_000_000
        feature_names: ["weighted_latency_1"]
